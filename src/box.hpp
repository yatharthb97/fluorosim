//box.hpp
#pragma once
/////////////////////////

// Libraries
#include <fstream>
#include<sstream>
#include <cmath>
#include <random>
#include<iomanip>
#include<string>
#include<vector>
#include<cstdint>
#include <iostream>
#include <stdlib.h>

#include "macros.hpp"
#include "particle.hpp"
#include "gl.hpp"
#include "clock.hpp"
#include "units.hpp"
#include "phenomena.hpp"

#include "./submodules/vector.hpp"
#include "./submodules/random.hpp"
//#include "./submodules/filesystem.hpp"
#include "./submodules/timer.hpp"
#include "./submodules/json/single_include/nlohmann/json.hpp"   //Json Library Used


//TODO → PSF_OFFSET_OPTIMIZATION --> Needs to be turned off for FCS_SYMMETRIC_BOX == False.
//     → SetPSFOffset func → Validates with the given boxsize.
//     → 
template <class Fluorophore> 
class LangevinBox
{

private:
	//private declarations



public:

// ------------------------   Member Variables   ---------------------------------

  //1. Set Box Configuration
  int BoxID = 0;//-------------------------------> Unique ID Assigned to the Box
  unsigned int dim = 3;//------------------------> dimensions of box-system


  //2. Extern Objects
  Veff veff; //! Single Veff-PSF Object coupled to the box
  Units units; //! Units conversion class

  //3. Box Configuration
  double Edge;//-------------------------> Edge of the box
  double Vol;//--------------------------> Volume of Box
  double Rho;//--------------------------> Number Density
  unsigned long int Part_no;//-----------> Number of particles in the box
  

  double MSD = 0;//----------------------> MSD Value for the entire evolution
  simcounter_t SimCounter = 0;//----> Simulation Counter


  //4. List Resources
  std::vector<ColorDetector> detectorlist; //List of detectors
  std::vector<Laser> laserlist;
  std::vector<Fluorophore> partlist; //Frequently refereed to as partlist_t partlist
  

  //6. PRNG Resources
  MT_RND rnd; //MT PRNG
  std::uniform_real_distribution<double> u_dist; // Uniform dist
  std::normal_distribution<double> gauss_dist; // Normal dist. for Langevin

  //7. Datapipe
  Datapipe datapipe;

  //8. String Resources
  std::string box_path;
  std::string raw_path;
  std::string profile_str;


// ------------------------   Member Functions  ---------------------------------


  	//1. Trivial Constructor (deleated explicitly)
  	LangevinBox() = delete;

  	//2. Default Constructor
  	LangevinBox(const double Rho, const unsigned int Part_no,	const Veff &veff, const Units &units) 
  				: Rho(Rho), Part_no(Part_no), veff(veff), units(units)
  	{

      //Edge and parameter setting
      this->Edge = std::cbrt(Part_no/Rho);
      this->Vol = Edge * Edge * Edge;


      //Call Box Init
  	  this->Init();

  	}

  	//3.0 Initilization function
  	void Init(const Fluorophore &flp)
  	{
  	
      //3.1
      set_session(); //Assign path and initalize a session.
  	
      //3.2.1 Prepare RND Generator ////////////////////////////////////////////
  	  rnd.NewSeeds(); //Seed PRNG
  	  rnd.Discard(1000000);  //Warm Up Generator

  	  std::string seedpath = box_path;
  	  seedpath.append("seeds");
  	  seedpath.append(FCS_DATAFILE_EXT);

  	  rnd.SaveSeed(seedpath); //Save Seeds for the simulation
 
      //////////////////////////////////////////////////////////////////////////

      //3.2.2 Reset the distribution parameters explictly
      u_dist.param(std::uniform_real_distribution<double>::param_type(0.0, 1.0));
      gauss_dist.param(std::normal_distribution<double>::param_type(0.0, 1.0));


      //3.2.3 Sampling if enabled
      #if FCS_RND_SAMPLING == 1
        for(unsigned int i = 0; i < FCS_RND_SAMPLE_SIZE; i++)
        {
          datapipe.u_dist << u_dist(rnd.engine) << '\n';
          datapipe.gauss_dist << gauss_dist(rnd.engine) << '\n';
        }

        //Reseed
        rnd.Reseed(); //Use the seeds generated by NewSeeds()
        rnd.Discard(1000000);  //Warm Up Generator
      #endif

  		//3.4 Particle Init
  		partlist.reserve(Part_no);
  		for(int i = 0; i < Part_no; i++)
  		{
  				//Particle(unsigned int partid, V &pos)
  		  	V posx(rnd_pos(), rnd_pos(), rnd_pos());

          Fluorophore flx = 
  		  	partlist.emplace_back(posx);
  		}


	    //3.5 Print Box Profile
	    this->profile_str = this->profile();
	    std::cout << "\n\n ————→  New Box Created  ←————" << '\n';

	    std::cout << this->profile_str << std::flush;
    ////////////////////////////////////////////////

    	//3.6. Write Config
    	JsonConfigWrite(box_path);

      //3.7. Write 0th position frame
      WritePosFrame(partlist, 0);
  	
    } //End of Init()

    /**
     * @brief Returns a gaussian distributed random number using the random resources of the box. */
    double inline gauss_rnd()
    {
      return gauss_dist(rnd.engine);
    }
    
    /**
     * @brief Returns a uniform distributed random number using the random resources of the box. */
    double inline uni_rnd()
    {
      return u_dist(rnd.engine);
    }

    /**
     * @brief Returns a random position (V) within the box. */
  	double rnd_pos() //For Initalization → returns one rnd coordinate
  	{
  		#if FCS_SYMMETRIC_BOX == 1
  			return Edge * (0.5 - u_dist(rnd.engine)); //Symmetric Box
  		#elif FCS_SYMMETRIC_BOX == 0
  			return Edge * u_dist(rnd.engine); //Assymetric Box
  		#endif

  	}

  	/**
     * @brief Function that implements `PBC → Periodic Boundary Condition` for the box. */
    void pbc(V &pos)
    {
      
      #if FCS_SYMMETRIC_BOX == 1  //Symmetric Box
        pos.x -= Edge * rint(pos.x/Edge);
        pos.y -= Edge * rint(pos.y/Edge);
        pos.z -= Edge * rint(pos.z/Edge);
      #elif FCS_SYMMETRIC_BOX == 0 //Assymetric Box
        pos.x = (pos.x > Edge)*(pos.x - Edge) + (pos.x < 0)*(Edge + pos.x);
        pos.y = (pos.y > Edge)*(pos.y - Edge) + (pos.y < 0)*(Edge + pos.y);
        pos.z = (pos.z > Edge)*(pos.z - Edge) + (pos.z < 0)*(Edge + pos.z);
      #endif

    } //End of PBC()

    /**
     * @brief Adds the given particles to the box.
     * @param The particle which is copied as it is but its position and pid is changed.
     * @param N - number of copies of particles that are added to the box.
     * @param Flag that specifies whether the density should be adjusted or not. True value maintains the current density.*/
    template <class Fluorophore> 
    void add_particle(const Fluorophore flp, const unsigned int N, const bool keep_density_constant)
    {
        
      unsigned int new_Part_no = this->Part_no + N;
      
      if(keep_density_constant)
      {
        //Update the Edges to keep the density constant
        this->Edge = std::cbrt(new_Part_no/this->Rho);
        this->Vol = Edge * Edge * Edge;

      }

      else
      {
        //Update the density to keep the Edges constant.
        this->Rho = new_Part_no/(Edge * Edge * Edge);
      }

      //VERBOSE("Added N particles with color {color_t_str(color)}, and diffusivity {D}.");
      partlist.reserve(N);
      for(int i = 0; i < N; i++)
      {
        Fluorophore fl_temp = flp;

        V pos_temp = V(rnd_pos(), rnd_pos(), rnd_pos()); 
        fl_temp.Pos = pos_temp;
        fl_temp.Partid = Part_no;

        partlist.emplace_back(fl_temp);
        
        this->Part_no++;
      }


    } //End of add_particle()


    /**
     * @brief Couple the passed detector to the box and activate its detection ability from the next clock cycle. */
    void add_detector(const Detector &detector)
    {
      //VERBOSE("Added detector with color {color_t_str(detector.Channel)}.);
      detectorlist.emplace_back(detector);
    }


    /**
     * @brief Couple the passed laser to the box and start its operation from the next clock cycle. */
    void add_laser(const Laser &laser)
    {
      //VERBOSE("Added laser with color {color_t_str(laser.Color)}.);
      laserlist.emplace_back(laser);
    }


    /**
     * @brief This function executes a complete dynamics cycle. Each particle is moved according to the Stochastic Euler update scheme. <x^2> = 2*dim*D*dt = 4*D*t  ==> 18*t = MSD =<r^2>. 
     * @param Simulation time. */
    void inline dynamics_cycle(simcounter_t Time)
    {
      for(auto &part : this->partlist)
      {
        double scalar = std::sqrt(2 * this->dim * part.get_D() * clock.stepsize(Phenomena::Brownian));
        
        V translation = V::generate_mul(scalar, this->gauss_rnd);
        part.translate(translation);
        
        #if FCS_ENABLE_PBC == 1
          pbc(part.Pos);
        #endif
      }
    }

    /**
     * @brief This function executes a complete photophysical cycle. For each laser, the whole particle list is subjected to an absorbance and an emission cycle.
     * @param Simulation time. */
    void inline photophysics_cycle(simcounter_t Time)
    {
      //Loop for each laser   
      for(auto &laser : laserlist)
      {  
        //Loop → absorbance
        for(auto &part : this->partlist)
        {
          //Absorbance depends on the external environment - laser intensity & veff intensity
          if(gauss_rnd() <= (laser.get_color() == part.get_color()) * laser.intensity(Time) * veff.intensity(part.position()))
          {
            part.try_absorb(uni_rnd);
          }
        }

        //Loop → emittance
        for(auto &part : this->partlist)
        {
          part.try_emit(uni_rnd);
        }
      }

    } //End of photophysics_cycle()


    /**
     * @brief This function executes a complete detection cycle. For each particle, each detectior checks for the appropriate emission. */
    void inline detection_cycle()
    {
      //Loop → detection
      for(auto &part : this->partlist)
      {                
        #pragma unroll //unroll this loop in compilation
        for(auto &det : detectorlist) 
        {
          det.detect(det.filter(part.get_color()), part.Emit_Flag); //(0 or 1, bool detectable)
        }
      }
    }


    /**
     * @brief Evolve function. Evolves the box in time. This function advances the state of the simulation.
     * @param Clock object - Object that controls the time partitioning and maximum steps advanced by the simulation engine. 
     * @param Camera object - Object that controls the number of frames generated. */
    void evolve(Clock &clock, Camera &camera)
    {
        const discrete_freq_t outerloop =  camera.get_snaps();
        const discrete_freq_t inner_brownainloop = clock.max_steps(Evol::Brownian)/outerloop;
        const discrete_freq_t inner_photoloop =  
                              clock.has_nested_order(Phenomena::Brownian, Phenomena::Photophysics) * 
                              clock.discrete_rel_freq(Evol::Photophysics, Evol::Brownian);
        
        //Print Information
        std::ostringstream info;
        info << "• Snapshots: " << outerloop;
        info << "\n • Brownian Steps: " << clock.max_steps(Evol::Brownian);
        info << "\n • Photosteps per Brownian steps: " << inner_photoloop << '\n';
        std::cout << info.str();
        //Print Information


        //Start TimerHD - simulation
        time_simulation("Box::evolve → Simulation Block");

          //Outer Loop → For Snapshots
          for(simcounter_t k = 0; j < outerloop; j++) //Outer Loop
          {

              //Brownian Loop
              for(simcounter_t j = 0; j < inner_brownainloop; j++) //Inner Brownian Loop
              {
                //For One Brownian Time Step ↓        

                //Increment SimCounter
                this->SimCounter++;

                //Move the particles
                dynamics_cycle(this->SimCounter);

                for(simcounter_t i = 0; i < inner_photoloop; i++) //Inner Photophysics Loop
                {
                  //Photophysics cycle
                  photophysics_cycle(this->SimCounter);

                  //Detection Cycle
                  detection_cycle(this->SimCounter);

                } //End of photophysical loop

              //Data Acqusition ------------------------

                //Particle Tagging (Only if enabled)
                #if FCS_PART_TAGGING == 1
                  datapipe.tag << partlist[FCS_TAG_PARTID].position().info(FCS_DSep) << '\n';
                #endif //FCS_PART_TAGGING

                //MSD Calculation        
                double MSDi = this->calc_msd();
                
                MSD += (MSDi)/double(Part_no); //Total MSD count per particle

                                  //Simulation Time               //MSD
                datapipe.msd << this->SimCounter << FCS_DSep << MSD/double(this->SimCounter) << '\n';
                  

                datapipe.detectors << this->SimCounter << FCS_DSep;
                #pragma unroll  //Append Detector Counts to the datapipe      
                for(auto &detector : detectorlist)
                {
                  datapipe.detectors << detector.get_count() << FCS_DSep;
                }

                datapipe.detectors << '\n';

              //Data Acqusition ------------------------  

                #pragma unroll  //Reset Detectors
                for(auto &detector : detectorlist)
                {
                  detector.reset();
                } 

              } //End of Brownian Loop


              ////6.3.4 FrameExport - TODO → Introduce a camera based - get_snap_name() function
              write_pos_frame(partlist, j+1);

          } //End of Outer Snapshot Loop

        time_simulation.Stop(); //End TimerHD - simulation

        //Launch Analysis Script
        if(gl::run_python)
        {
          launch_py_analysis();
        }

    } //End of evolve()


    //Saves the dat file of the box snapshot
    void write_pos_frame(partlist_t &partlist_t, unsigned long int frameid) const
    {
      std::ostringstream buffer;
      buffer << std::setprecision(FCS_FLOAT_PRECISION);


      unsigned int sizex = partlist.size();
      for(unsigned int i = 0; i < sizex; i++) 
      {
        buffer << partlist[i].partid << FCS_DSep << partlist[i].position().info(FCS_DSep) << FCS_DSep
                  //1. Partid                          //2-4. Position {x,y,z}
               << static_cast<unsigned int>(partlist[i].Fl_State) << FCS_DSep 
                  //5. Fluorescence State

               << partlist[i].Emit_Flag << '\n';
                  //6. Emit State?
      }


      std::string filename = raw_path;
      filename.append(std::to_string(frameid));
      filename.append(FCS_DATAFILE_EXT);

      std::ofstream file(filename, std::ios::out); //Write to file
      file << buffer.str();  //Open File
      file.close();  //Close File

    } // End of FrameExport()




    void inline json_config(const std::string &parentpath, const simcounter_t current_time)
    {
    	
    	using json = nlohmann::json;  // for convenience

    	json config; //Init Json Object

    	config["parent_path"] =  this->box_path;
      config["raw_path"] = this->raw_path;
    	
      config["Edge"] = this->Edge;
    	config["Part_no"] = this->Part_no;
      config["dim"] = this->dim;

    	config["run_python"] = gl::run_python; //Specifies History → Unused [[unused]]
    	config["do_pos_plots"] = gl::do_pos_plots ;
    	config["show_plots"] = gl::show_py_plots;



      //Detectors
      for(const auto &det: detectorlist)
      {
        config["detectors_description"] << det.profile();
      }

      //Lasers
      for(const auto &laser: laserlist)
      {
        config["lasers_description"] << lasers.profile();
      }


 

    	//veff

    	//Note that char types are not automatically converted to JSON strings, but to integer numbers. A conversion to a string must be specified explicitly (source: library docs)
    	//MACROS
      config["Symmetric Box"] = bool(FCS_SYMMETRIC_BOX);
    	



      // ---- MACROS -------------------------------

      config["d_sep"] = std::string(1, FCS_DSep);//---------------------->6
      config["pbc"] = bool(FCS_ENABLE_PBC);
 
      config["part_tagging"] = bool(FCS_PART_TAGGING);
      config["prng_sampling"] =bool(FCS_RND_SAMPLING);
      //Particle Tagging (if enabled)
      #if FCS_PART_TAGGING == 1
        config["tagged_partid"] = unsigned int(FCS_TAG_PARTID);
      #else
        config["tagged_partid"] = "No Particle Tagged!";
      #endif


    	//Open(Create) File
    	std::string filename = parentpath;
    	filename.append("config.json");
    	std::ofstream file(filename, std::ios::out);
    	
    	file << std::setw(4) << config; //Write to file with intendation ws = 4
    	file.close(); //Close file
      
    } //End of JsonConfigWrite()


    std::string profile() const
    {
    	
    	std::ostringstream buffer;
    	buffer << std::setprecision(FCS_FLOAT_SHORT_PRECISION) << std::boolalpha;
    	
      buffer << " • BoxID: " << this->BoxID << " | Box Path: " << this->box_path << '\n';
    	buffer << " • First Seed used for MT PRNG: " << rnd.FirstSeed() << '\n';

    	buffer << "\n\t\t————→  Box Parameters  ←————\n"; //BOX
    	buffer << " • Box Edge: "<< Edge << " | No. Density: " << Rho << " | Particles: " << Part_no;
      buffer << "\n • Concentration: " << Rho * 1e-6/(CONST_Avogadro * units.stor_volume())<< " mol/cm3"
             << " | • Box Volume: "<< this->Vol << '\n';

    	//Declare if Symmetric Box and if Gaussian PSF
    	buffer << " • Box Symmetric: " << (FCS_SYMMETRIC_BOX == 1)


      //Iteration over the current - laser, veff, and detectorlist


      double femto_vol = veff.get_vol() * units.stor_volume() * 1e18;
    	
      buffer << "\n\t\t————→  Effective Volume  ←————\n"; //VEFF
      buffer << " • Veff → " << veff.get_veff_type() << '\n';
      buffer << " • Veff Volume/Box Volume: " << veff.get_vol()/this->Vol << " | Real Vol: "<< femto_vol <<" fL \n";
      buffer << " • Volume of Veff: " << veff.get_vol() << " | Veff Radial Radius(x-y): " << veff.get_rad_radius() << '\n';
    	buffer << " • z-Radius: " << veff.get_z_radius() << " | Structure Factor: " << veff.get_sf() << "\n";
    	

      buffer << "\n\t\t————→  Lasers  ←————\n";
      for(unsigned int i = 0; i < laserlist.size(); i++)
      {
        buffer << i << ". " << laserlist.at(i).profile() << '\n';
      }

      buffer << "\n\t\t————→  Detectors  ←————\n";
      for(unsigned int i = 0; i < detectorlist.size(); i++)
      {
        buffer << i << ". " << color::color_str(detectorlist.at(i).Color) << " Detector \n";
      }
     
    	//---
    	buffer << units.profile() << '\n';

      buffer << "\n\t\t\t————→ • • • ←————\n";

    	return buffer.str();

    } //End of profile()


    void set_session()
    {
          //3.0 Check if global NewSession was called.
          if(!gl::session_declared)
          {
            std::cerr << "[FATAL ERROR] NewSession() was not called before of LangevinBox().\n";
            exit(-1);
          }

          
          //3.1 BoxPath Creation ////// TODO → Mutax Protect
          gl::boxcounter++;
          this->BoxID = gl::boxcounter; //Set BoxID


          //Assumes → gl::session_path is guarenteed to be a valid path.

         if(this->BoxID == 0 && gl::boxmode == "singlebox")
          {
            //No Subfolder is created
            this->box_path = gl::session_path;
            
            this->raw_path = box_path; raw_path.append("Raw/");
            mkdir(raw_path.c_str(), 0777);
          }

          else if(this->BoxID > 1 && gl::boxmode == "singlebox")
          {
            //Invalid State
            std::cerr << "[ERROR] New box cannot be created in \"singlebox\" mode.\n Set up session with \"multibox\" mode.\n";
            exit(-1);
          }


          else if(gl::boxmode == "multibox")
          {
            //Create Subfolder
            std::string path = gl::session_path;
            
            path.append(std::to_string(BoxID));
            FileSystem::SlashIt(path);
            this->box_path = path;

            //Make Subfolder
            mkdir(path.c_str(), 0777);

            this->raw_path = box_path; raw_path.append("Raw/");
            mkdir(raw_path.c_str(), 0777);
          }

          else
            std::cerr << "[FATAL ERROR] Invalid State:" << __LINE__ << __FILE__ << '\n';
    } //End of SetSession()


    void launch_py_analysis() const
    {
        TimerHD time_for_plotting("Python Analysis");
        
        std::ostringstream command;
        command << "python3  ./src/python/analysis.py" << "  " //-----> Script Name
                << this->box_path << "  " //----------> Box Path
                << "C++";  //-------------------------> Operation Mode
        int sys_return = system(command.str().c_str());

        time_for_plotting.Stop(); //Destroy object
    } //End of Launch_Python_Analysis()


    /**
     * Returns the accumulated *Mean Squared Displacement (MSD)* of all the particles in the particlelist. */
    double inline calc_msd() const
    {
      double MSD = 0;
      for(const auto &part : partlist)
      {
        MSD += part.get_init_displacement().size_sq();
      }

      return MSD/double(Part_no);
    }

}; //End of class LangevinBox[]

//Concepts ↓

